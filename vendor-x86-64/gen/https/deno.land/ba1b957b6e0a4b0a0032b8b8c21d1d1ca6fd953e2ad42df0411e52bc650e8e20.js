// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { bgGreen, bgRed, bold, gray, green, red, white } from "../fmt/colors.ts";
export const DiffType = {
  removed: "removed",
  common: "common",
  added: "added"
};
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse) {
  const common = [];
  if (A.length === 0 || B.length === 0) return [];
  for(let i = 0; i < Math.min(A.length, B.length); i += 1){
    const a = reverse ? A[A.length - i - 1] : A[i];
    const b = reverse ? B[B.length - i - 1] : B[i];
    if (a !== undefined && a === b) {
      common.push(a);
    } else {
      return common;
    }
  }
  return common;
}
function ensureDefined(item) {
  if (item === undefined) {
    throw Error("Unexpected missing FarthestPoint");
  }
  return item;
}
/**
 * Renders the differences between the actual and expected values
 * @param A Actual value
 * @param B Expected value
 */ export function diff(A, B) {
  const prefixCommon = createCommon(A, B);
  const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
  A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);
  B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);
  const swapped = B.length > A.length;
  [A, B] = swapped ? [
    B,
    A
  ] : [
    A,
    B
  ];
  const M = A.length;
  const N = B.length;
  if (!M && !N && !suffixCommon.length && !prefixCommon.length) return [];
  if (!N) {
    return [
      ...prefixCommon.map((c)=>({
          type: DiffType.common,
          value: c
        })),
      ...A.map((a)=>({
          type: swapped ? DiffType.added : DiffType.removed,
          value: a
        })),
      ...suffixCommon.map((c)=>({
          type: DiffType.common,
          value: c
        }))
    ];
  }
  const offset = N;
  const delta = M - N;
  const size = M + N + 1;
  const fp = Array.from({
    length: size
  }, ()=>({
      y: -1,
      id: -1
    }));
  /**
   * INFO:
   * This buffer is used to save memory and improve performance.
   * The first half is used to save route and last half is used to save diff
   * type.
   * This is because, when I kept new uint8array area to save type,performance
   * worsened.
   */ const routes = new Uint32Array((M * N + size + 1) * 2);
  const diffTypesPtrOffset = routes.length / 2;
  let ptr = 0;
  let p = -1;
  function backTrace(A, B, current, swapped) {
    const M = A.length;
    const N = B.length;
    const result = [];
    let a = M - 1;
    let b = N - 1;
    let j = routes[current.id];
    let type = routes[current.id + diffTypesPtrOffset];
    while(true){
      if (!j && !type) break;
      const prev = j;
      if (type === REMOVED) {
        result.unshift({
          type: swapped ? DiffType.removed : DiffType.added,
          value: B[b]
        });
        b -= 1;
      } else if (type === ADDED) {
        result.unshift({
          type: swapped ? DiffType.added : DiffType.removed,
          value: A[a]
        });
        a -= 1;
      } else {
        result.unshift({
          type: DiffType.common,
          value: A[a]
        });
        a -= 1;
        b -= 1;
      }
      j = routes[prev];
      type = routes[prev + diffTypesPtrOffset];
    }
    return result;
  }
  function createFP(slide, down, k, M) {
    if (slide && slide.y === -1 && down && down.y === -1) {
      return {
        y: 0,
        id: 0
      };
    }
    const isAdding = down?.y === -1 || k === M || (slide?.y || 0) > (down?.y || 0) + 1;
    if (slide && isAdding) {
      const prev = slide.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = ADDED;
      return {
        y: slide.y,
        id: ptr
      };
    } else if (down && !isAdding) {
      const prev = down.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = REMOVED;
      return {
        y: down.y + 1,
        id: ptr
      };
    } else {
      throw new Error("Unexpected missing FarthestPoint");
    }
  }
  function snake(k, slide, down, _offset, A, B) {
    const M = A.length;
    const N = B.length;
    if (k < -N || M < k) return {
      y: -1,
      id: -1
    };
    const fp = createFP(slide, down, k, M);
    while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){
      const prev = fp.id;
      ptr++;
      fp.id = ptr;
      fp.y += 1;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = COMMON;
    }
    return fp;
  }
  let currentFP = ensureDefined(fp[delta + offset]);
  while(currentFP && currentFP.y < N){
    p = p + 1;
    for(let k = -p; k < delta; ++k){
      fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
    }
    for(let k = delta + p; k > delta; --k){
      fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
    }
    fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
    currentFP = ensureDefined(fp[delta + offset]);
  }
  return [
    ...prefixCommon.map((c)=>({
        type: DiffType.common,
        value: c
      })),
    ...backTrace(A, B, currentFP, swapped),
    ...suffixCommon.map((c)=>({
        type: DiffType.common,
        value: c
      }))
  ];
}
/**
 * Renders the differences between the actual and expected strings
 * Partially inspired from https://github.com/kpdecker/jsdiff
 * @param A Actual string
 * @param B Expected string
 */ export function diffstr(A, B) {
  function unescape(string) {
    // unescape invisible characters.
    // ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#escape_sequences
    return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\t", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str)=>str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
  }
  function tokenize(string, { wordDiff = false } = {}) {
    if (wordDiff) {
      // Split string on whitespace symbols
      const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
      // Extended Latin character set
      const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
      // Join boundary splits that we do not consider to be boundaries and merge empty strings surrounded by word chars
      for(let i = 0; i < tokens.length - 1; i++){
        const token = tokens[i];
        const tokenPlusTwo = tokens[i + 2];
        if (!tokens[i + 1] && token && tokenPlusTwo && words.test(token) && words.test(tokenPlusTwo)) {
          tokens[i] += tokenPlusTwo;
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens.filter((token)=>token);
    } else {
      // Split string on new lines symbols
      const tokens = [];
      const lines = string.split(/(\n|\r\n)/);
      // Ignore final empty token when text ends with a newline
      if (!lines[lines.length - 1]) {
        lines.pop();
      }
      // Merge the content and line separators into single tokens
      for (const [i, line] of lines.entries()){
        if (i % 2) {
          tokens[tokens.length - 1] += line;
        } else {
          tokens.push(line);
        }
      }
      return tokens;
    }
  }
  // Create details by filtering relevant word-diff for current line
  // and merge "space-diff" if surrounded by word-diff for cleaner displays
  function createDetails(line, tokens) {
    return tokens.filter(({ type })=>type === line.type || type === DiffType.common).map((result, i, t)=>{
      const token = t[i - 1];
      if (result.type === DiffType.common && token && token.type === t[i + 1]?.type && /\s+/.test(result.value)) {
        return {
          ...result,
          type: token.type
        };
      }
      return result;
    });
  }
  // Compute multi-line diff
  const diffResult = diff(tokenize(`${unescape(A)}\n`), tokenize(`${unescape(B)}\n`));
  const added = [], removed = [];
  for (const result of diffResult){
    if (result.type === DiffType.added) {
      added.push(result);
    }
    if (result.type === DiffType.removed) {
      removed.push(result);
    }
  }
  // Compute word-diff
  const hasMoreRemovedLines = added.length < removed.length;
  const aLines = hasMoreRemovedLines ? added : removed;
  const bLines = hasMoreRemovedLines ? removed : added;
  for (const a of aLines){
    let tokens = [], b;
    // Search another diff line with at least one common token
    while(bLines.length){
      b = bLines.shift();
      const tokenized = [
        tokenize(a.value, {
          wordDiff: true
        }),
        tokenize(b?.value ?? "", {
          wordDiff: true
        })
      ];
      if (hasMoreRemovedLines) tokenized.reverse();
      tokens = diff(tokenized[0], tokenized[1]);
      if (tokens.some(({ type, value })=>type === DiffType.common && value.trim().length)) {
        break;
      }
    }
    // Register word-diff details
    a.details = createDetails(a, tokens);
    if (b) {
      b.details = createDetails(b, tokens);
    }
  }
  return diffResult;
}
/**
 * Colors the output of assertion diffs
 * @param diffType Difference type, either added or removed
 */ function createColor(diffType, { background = false } = {}) {
  // TODO(@littledivy): Remove this when we can detect
  // true color terminals.
  // https://github.com/denoland/deno_std/issues/2575
  background = false;
  switch(diffType){
    case DiffType.added:
      return (s)=>background ? bgGreen(white(s)) : green(bold(s));
    case DiffType.removed:
      return (s)=>background ? bgRed(white(s)) : red(bold(s));
    default:
      return white;
  }
}
/**
 * Prefixes `+` or `-` in diff output
 * @param diffType Difference type, either added or removed
 */ function createSign(diffType) {
  switch(diffType){
    case DiffType.added:
      return "+   ";
    case DiffType.removed:
      return "-   ";
    default:
      return "    ";
  }
}
export function buildMessage(diffResult, { stringDiff = false } = {}) {
  const messages = [], diffMessages = [];
  messages.push("");
  messages.push("");
  messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
  messages.push("");
  messages.push("");
  diffResult.forEach((result)=>{
    const c = createColor(result.type);
    const line = result.details?.map((detail)=>detail.type !== DiffType.common ? createColor(detail.type, {
        background: true
      })(detail.value) : detail.value).join("") ?? result.value;
    diffMessages.push(c(`${createSign(result.type)}${line}`));
  });
  messages.push(...stringDiff ? [
    diffMessages.join("")
  ] : diffMessages);
  messages.push("");
  return messages;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3N0ZEAwLjIxNi4wL2Fzc2VydC9fZGlmZi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDI0IHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuXG5pbXBvcnQge1xuICBiZ0dyZWVuLFxuICBiZ1JlZCxcbiAgYm9sZCxcbiAgZ3JheSxcbiAgZ3JlZW4sXG4gIHJlZCxcbiAgd2hpdGUsXG59IGZyb20gXCIuLi9mbXQvY29sb3JzLnRzXCI7XG5cbmludGVyZmFjZSBGYXJ0aGVzdFBvaW50IHtcbiAgeTogbnVtYmVyO1xuICBpZDogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgRGlmZlR5cGUgPSB7XG4gIHJlbW92ZWQ6IFwicmVtb3ZlZFwiLFxuICBjb21tb246IFwiY29tbW9uXCIsXG4gIGFkZGVkOiBcImFkZGVkXCIsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBEaWZmVHlwZSA9IGtleW9mIHR5cGVvZiBEaWZmVHlwZTtcblxuZXhwb3J0IGludGVyZmFjZSBEaWZmUmVzdWx0PFQ+IHtcbiAgdHlwZTogRGlmZlR5cGU7XG4gIHZhbHVlOiBUO1xuICBkZXRhaWxzPzogQXJyYXk8RGlmZlJlc3VsdDxUPj47XG59XG5cbmNvbnN0IFJFTU9WRUQgPSAxO1xuY29uc3QgQ09NTU9OID0gMjtcbmNvbnN0IEFEREVEID0gMztcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uPFQ+KEE6IFRbXSwgQjogVFtdLCByZXZlcnNlPzogYm9vbGVhbik6IFRbXSB7XG4gIGNvbnN0IGNvbW1vbjogVFtdID0gW107XG4gIGlmIChBLmxlbmd0aCA9PT0gMCB8fCBCLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKEEubGVuZ3RoLCBCLmxlbmd0aCk7IGkgKz0gMSkge1xuICAgIGNvbnN0IGEgPSByZXZlcnNlID8gQVtBLmxlbmd0aCAtIGkgLSAxXSA6IEFbaV07XG4gICAgY29uc3QgYiA9IHJldmVyc2UgPyBCW0IubGVuZ3RoIC0gaSAtIDFdIDogQltpXTtcbiAgICBpZiAoYSAhPT0gdW5kZWZpbmVkICYmIGEgPT09IGIpIHtcbiAgICAgIGNvbW1vbi5wdXNoKGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tbW9uO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tbW9uO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVEZWZpbmVkPFQ+KGl0ZW0/OiBUKTogVCB7XG4gIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgbWlzc2luZyBGYXJ0aGVzdFBvaW50XCIpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzXG4gKiBAcGFyYW0gQSBBY3R1YWwgdmFsdWVcbiAqIEBwYXJhbSBCIEV4cGVjdGVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmPFQ+KEE6IFRbXSwgQjogVFtdKTogQXJyYXk8RGlmZlJlc3VsdDxUPj4ge1xuICBjb25zdCBwcmVmaXhDb21tb24gPSBjcmVhdGVDb21tb24oQSwgQik7XG4gIGNvbnN0IHN1ZmZpeENvbW1vbiA9IGNyZWF0ZUNvbW1vbihcbiAgICBBLnNsaWNlKHByZWZpeENvbW1vbi5sZW5ndGgpLFxuICAgIEIuc2xpY2UocHJlZml4Q29tbW9uLmxlbmd0aCksXG4gICAgdHJ1ZSxcbiAgKS5yZXZlcnNlKCk7XG4gIEEgPSBzdWZmaXhDb21tb24ubGVuZ3RoXG4gICAgPyBBLnNsaWNlKHByZWZpeENvbW1vbi5sZW5ndGgsIC1zdWZmaXhDb21tb24ubGVuZ3RoKVxuICAgIDogQS5zbGljZShwcmVmaXhDb21tb24ubGVuZ3RoKTtcbiAgQiA9IHN1ZmZpeENvbW1vbi5sZW5ndGhcbiAgICA/IEIuc2xpY2UocHJlZml4Q29tbW9uLmxlbmd0aCwgLXN1ZmZpeENvbW1vbi5sZW5ndGgpXG4gICAgOiBCLnNsaWNlKHByZWZpeENvbW1vbi5sZW5ndGgpO1xuICBjb25zdCBzd2FwcGVkID0gQi5sZW5ndGggPiBBLmxlbmd0aDtcbiAgW0EsIEJdID0gc3dhcHBlZCA/IFtCLCBBXSA6IFtBLCBCXTtcbiAgY29uc3QgTSA9IEEubGVuZ3RoO1xuICBjb25zdCBOID0gQi5sZW5ndGg7XG4gIGlmICghTSAmJiAhTiAmJiAhc3VmZml4Q29tbW9uLmxlbmd0aCAmJiAhcHJlZml4Q29tbW9uLmxlbmd0aCkgcmV0dXJuIFtdO1xuICBpZiAoIU4pIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4ucHJlZml4Q29tbW9uLm1hcChcbiAgICAgICAgKGMpOiBEaWZmUmVzdWx0PHR5cGVvZiBjPiA9PiAoeyB0eXBlOiBEaWZmVHlwZS5jb21tb24sIHZhbHVlOiBjIH0pLFxuICAgICAgKSxcbiAgICAgIC4uLkEubWFwKFxuICAgICAgICAoYSk6IERpZmZSZXN1bHQ8dHlwZW9mIGE+ID0+ICh7XG4gICAgICAgICAgdHlwZTogc3dhcHBlZCA/IERpZmZUeXBlLmFkZGVkIDogRGlmZlR5cGUucmVtb3ZlZCxcbiAgICAgICAgICB2YWx1ZTogYSxcbiAgICAgICAgfSksXG4gICAgICApLFxuICAgICAgLi4uc3VmZml4Q29tbW9uLm1hcChcbiAgICAgICAgKGMpOiBEaWZmUmVzdWx0PHR5cGVvZiBjPiA9PiAoeyB0eXBlOiBEaWZmVHlwZS5jb21tb24sIHZhbHVlOiBjIH0pLFxuICAgICAgKSxcbiAgICBdO1xuICB9XG4gIGNvbnN0IG9mZnNldCA9IE47XG4gIGNvbnN0IGRlbHRhID0gTSAtIE47XG4gIGNvbnN0IHNpemUgPSBNICsgTiArIDE7XG4gIGNvbnN0IGZwOiBGYXJ0aGVzdFBvaW50W10gPSBBcnJheS5mcm9tKFxuICAgIHsgbGVuZ3RoOiBzaXplIH0sXG4gICAgKCkgPT4gKHsgeTogLTEsIGlkOiAtMSB9KSxcbiAgKTtcblxuICAvKipcbiAgICogSU5GTzpcbiAgICogVGhpcyBidWZmZXIgaXMgdXNlZCB0byBzYXZlIG1lbW9yeSBhbmQgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICogVGhlIGZpcnN0IGhhbGYgaXMgdXNlZCB0byBzYXZlIHJvdXRlIGFuZCBsYXN0IGhhbGYgaXMgdXNlZCB0byBzYXZlIGRpZmZcbiAgICogdHlwZS5cbiAgICogVGhpcyBpcyBiZWNhdXNlLCB3aGVuIEkga2VwdCBuZXcgdWludDhhcnJheSBhcmVhIHRvIHNhdmUgdHlwZSxwZXJmb3JtYW5jZVxuICAgKiB3b3JzZW5lZC5cbiAgICovXG4gIGNvbnN0IHJvdXRlcyA9IG5ldyBVaW50MzJBcnJheSgoTSAqIE4gKyBzaXplICsgMSkgKiAyKTtcbiAgY29uc3QgZGlmZlR5cGVzUHRyT2Zmc2V0ID0gcm91dGVzLmxlbmd0aCAvIDI7XG4gIGxldCBwdHIgPSAwO1xuICBsZXQgcCA9IC0xO1xuXG4gIGZ1bmN0aW9uIGJhY2tUcmFjZTxUPihcbiAgICBBOiBUW10sXG4gICAgQjogVFtdLFxuICAgIGN1cnJlbnQ6IEZhcnRoZXN0UG9pbnQsXG4gICAgc3dhcHBlZDogYm9vbGVhbixcbiAgKTogQXJyYXk8e1xuICAgIHR5cGU6IERpZmZUeXBlO1xuICAgIHZhbHVlOiBUO1xuICB9PiB7XG4gICAgY29uc3QgTSA9IEEubGVuZ3RoO1xuICAgIGNvbnN0IE4gPSBCLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQ6IHsgdHlwZTogRGlmZlR5cGU7IHZhbHVlOiBUIH1bXSA9IFtdO1xuICAgIGxldCBhID0gTSAtIDE7XG4gICAgbGV0IGIgPSBOIC0gMTtcbiAgICBsZXQgaiA9IHJvdXRlc1tjdXJyZW50LmlkXTtcbiAgICBsZXQgdHlwZSA9IHJvdXRlc1tjdXJyZW50LmlkICsgZGlmZlR5cGVzUHRyT2Zmc2V0XTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKCFqICYmICF0eXBlKSBicmVhaztcbiAgICAgIGNvbnN0IHByZXYgPSBqITtcbiAgICAgIGlmICh0eXBlID09PSBSRU1PVkVEKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHtcbiAgICAgICAgICB0eXBlOiBzd2FwcGVkID8gRGlmZlR5cGUucmVtb3ZlZCA6IERpZmZUeXBlLmFkZGVkLFxuICAgICAgICAgIHZhbHVlOiBCW2JdISxcbiAgICAgICAgfSk7XG4gICAgICAgIGIgLT0gMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQURERUQpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6IHN3YXBwZWQgPyBEaWZmVHlwZS5hZGRlZCA6IERpZmZUeXBlLnJlbW92ZWQsXG4gICAgICAgICAgdmFsdWU6IEFbYV0hLFxuICAgICAgICB9KTtcbiAgICAgICAgYSAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoeyB0eXBlOiBEaWZmVHlwZS5jb21tb24sIHZhbHVlOiBBW2FdISB9KTtcbiAgICAgICAgYSAtPSAxO1xuICAgICAgICBiIC09IDE7XG4gICAgICB9XG4gICAgICBqID0gcm91dGVzW3ByZXZdO1xuICAgICAgdHlwZSA9IHJvdXRlc1twcmV2ICsgZGlmZlR5cGVzUHRyT2Zmc2V0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZQKFxuICAgIHNsaWRlOiBGYXJ0aGVzdFBvaW50IHwgdW5kZWZpbmVkLFxuICAgIGRvd246IEZhcnRoZXN0UG9pbnQgfCB1bmRlZmluZWQsXG4gICAgazogbnVtYmVyLFxuICAgIE06IG51bWJlcixcbiAgKTogRmFydGhlc3RQb2ludCB7XG4gICAgaWYgKHNsaWRlICYmIHNsaWRlLnkgPT09IC0xICYmIGRvd24gJiYgZG93bi55ID09PSAtMSkge1xuICAgICAgcmV0dXJuIHsgeTogMCwgaWQ6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNBZGRpbmcgPSAoZG93bj8ueSA9PT0gLTEpIHx8XG4gICAgICBrID09PSBNIHx8XG4gICAgICAoc2xpZGU/LnkgfHwgMCkgPiAoZG93bj8ueSB8fCAwKSArIDE7XG4gICAgaWYgKHNsaWRlICYmIGlzQWRkaW5nKSB7XG4gICAgICBjb25zdCBwcmV2ID0gc2xpZGUuaWQ7XG4gICAgICBwdHIrKztcbiAgICAgIHJvdXRlc1twdHJdID0gcHJldjtcbiAgICAgIHJvdXRlc1twdHIgKyBkaWZmVHlwZXNQdHJPZmZzZXRdID0gQURERUQ7XG4gICAgICByZXR1cm4geyB5OiBzbGlkZS55LCBpZDogcHRyIH07XG4gICAgfSBlbHNlIGlmIChkb3duICYmICFpc0FkZGluZykge1xuICAgICAgY29uc3QgcHJldiA9IGRvd24uaWQ7XG4gICAgICBwdHIrKztcbiAgICAgIHJvdXRlc1twdHJdID0gcHJldjtcbiAgICAgIHJvdXRlc1twdHIgKyBkaWZmVHlwZXNQdHJPZmZzZXRdID0gUkVNT1ZFRDtcbiAgICAgIHJldHVybiB7IHk6IGRvd24ueSArIDEsIGlkOiBwdHIgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaXNzaW5nIEZhcnRoZXN0UG9pbnRcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc25ha2U8VD4oXG4gICAgazogbnVtYmVyLFxuICAgIHNsaWRlOiBGYXJ0aGVzdFBvaW50IHwgdW5kZWZpbmVkLFxuICAgIGRvd246IEZhcnRoZXN0UG9pbnQgfCB1bmRlZmluZWQsXG4gICAgX29mZnNldDogbnVtYmVyLFxuICAgIEE6IFRbXSxcbiAgICBCOiBUW10sXG4gICk6IEZhcnRoZXN0UG9pbnQge1xuICAgIGNvbnN0IE0gPSBBLmxlbmd0aDtcbiAgICBjb25zdCBOID0gQi5sZW5ndGg7XG4gICAgaWYgKGsgPCAtTiB8fCBNIDwgaykgcmV0dXJuIHsgeTogLTEsIGlkOiAtMSB9O1xuICAgIGNvbnN0IGZwID0gY3JlYXRlRlAoc2xpZGUsIGRvd24sIGssIE0pO1xuICAgIHdoaWxlIChmcC55ICsgayA8IE0gJiYgZnAueSA8IE4gJiYgQVtmcC55ICsga10gPT09IEJbZnAueV0pIHtcbiAgICAgIGNvbnN0IHByZXYgPSBmcC5pZDtcbiAgICAgIHB0cisrO1xuICAgICAgZnAuaWQgPSBwdHI7XG4gICAgICBmcC55ICs9IDE7XG4gICAgICByb3V0ZXNbcHRyXSA9IHByZXY7XG4gICAgICByb3V0ZXNbcHRyICsgZGlmZlR5cGVzUHRyT2Zmc2V0XSA9IENPTU1PTjtcbiAgICB9XG4gICAgcmV0dXJuIGZwO1xuICB9XG5cbiAgbGV0IGN1cnJlbnRGUCA9IGVuc3VyZURlZmluZWQ8RmFydGhlc3RQb2ludD4oZnBbZGVsdGEgKyBvZmZzZXRdKTtcbiAgd2hpbGUgKGN1cnJlbnRGUCAmJiBjdXJyZW50RlAueSA8IE4pIHtcbiAgICBwID0gcCArIDE7XG4gICAgZm9yIChsZXQgayA9IC1wOyBrIDwgZGVsdGE7ICsraykge1xuICAgICAgZnBbayArIG9mZnNldF0gPSBzbmFrZShcbiAgICAgICAgayxcbiAgICAgICAgZnBbayAtIDEgKyBvZmZzZXRdLFxuICAgICAgICBmcFtrICsgMSArIG9mZnNldF0sXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgQSxcbiAgICAgICAgQixcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAobGV0IGsgPSBkZWx0YSArIHA7IGsgPiBkZWx0YTsgLS1rKSB7XG4gICAgICBmcFtrICsgb2Zmc2V0XSA9IHNuYWtlKFxuICAgICAgICBrLFxuICAgICAgICBmcFtrIC0gMSArIG9mZnNldF0sXG4gICAgICAgIGZwW2sgKyAxICsgb2Zmc2V0XSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBBLFxuICAgICAgICBCLFxuICAgICAgKTtcbiAgICB9XG4gICAgZnBbZGVsdGEgKyBvZmZzZXRdID0gc25ha2UoXG4gICAgICBkZWx0YSxcbiAgICAgIGZwW2RlbHRhIC0gMSArIG9mZnNldF0sXG4gICAgICBmcFtkZWx0YSArIDEgKyBvZmZzZXRdLFxuICAgICAgb2Zmc2V0LFxuICAgICAgQSxcbiAgICAgIEIsXG4gICAgKTtcbiAgICBjdXJyZW50RlAgPSBlbnN1cmVEZWZpbmVkKGZwW2RlbHRhICsgb2Zmc2V0XSk7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICAuLi5wcmVmaXhDb21tb24ubWFwKFxuICAgICAgKGMpOiBEaWZmUmVzdWx0PHR5cGVvZiBjPiA9PiAoeyB0eXBlOiBEaWZmVHlwZS5jb21tb24sIHZhbHVlOiBjIH0pLFxuICAgICksXG4gICAgLi4uYmFja1RyYWNlKEEsIEIsIGN1cnJlbnRGUCwgc3dhcHBlZCksXG4gICAgLi4uc3VmZml4Q29tbW9uLm1hcChcbiAgICAgIChjKTogRGlmZlJlc3VsdDx0eXBlb2YgYz4gPT4gKHsgdHlwZTogRGlmZlR5cGUuY29tbW9uLCB2YWx1ZTogYyB9KSxcbiAgICApLFxuICBdO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgc3RyaW5nc1xuICogUGFydGlhbGx5IGluc3BpcmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2twZGVja2VyL2pzZGlmZlxuICogQHBhcmFtIEEgQWN0dWFsIHN0cmluZ1xuICogQHBhcmFtIEIgRXhwZWN0ZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmc3RyKEE6IHN0cmluZywgQjogc3RyaW5nKSB7XG4gIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyB1bmVzY2FwZSBpbnZpc2libGUgY2hhcmFjdGVycy5cbiAgICAvLyByZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZyNlc2NhcGVfc2VxdWVuY2VzXG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgLnJlcGxhY2VBbGwoXCJcXGJcIiwgXCJcXFxcYlwiKVxuICAgICAgLnJlcGxhY2VBbGwoXCJcXGZcIiwgXCJcXFxcZlwiKVxuICAgICAgLnJlcGxhY2VBbGwoXCJcXHRcIiwgXCJcXFxcdFwiKVxuICAgICAgLnJlcGxhY2VBbGwoXCJcXHZcIiwgXCJcXFxcdlwiKVxuICAgICAgLnJlcGxhY2VBbGwoIC8vIGRvZXMgbm90IHJlbW92ZSBsaW5lIGJyZWFrc1xuICAgICAgICAvXFxyXFxufFxccnxcXG4vZyxcbiAgICAgICAgKHN0cikgPT4gc3RyID09PSBcIlxcclwiID8gXCJcXFxcclwiIDogc3RyID09PSBcIlxcblwiID8gXCJcXFxcblxcblwiIDogXCJcXFxcclxcXFxuXFxyXFxuXCIsXG4gICAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5pemUoc3RyaW5nOiBzdHJpbmcsIHsgd29yZERpZmYgPSBmYWxzZSB9ID0ge30pOiBzdHJpbmdbXSB7XG4gICAgaWYgKHdvcmREaWZmKSB7XG4gICAgICAvLyBTcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZSBzeW1ib2xzXG4gICAgICBjb25zdCB0b2tlbnMgPSBzdHJpbmcuc3BsaXQoLyhbXlxcU1xcclxcbl0rfFsoKVtcXF17fSdcIlxcclxcbl18XFxiKS8pO1xuICAgICAgLy8gRXh0ZW5kZWQgTGF0aW4gY2hhcmFjdGVyIHNldFxuICAgICAgY29uc3Qgd29yZHMgPVxuICAgICAgICAvXlthLXpBLVpcXHV7QzB9LVxcdXtGRn1cXHV7RDh9LVxcdXtGNn1cXHV7Rjh9LVxcdXsyQzZ9XFx1ezJDOH0tXFx1ezJEN31cXHV7MkRFfS1cXHV7MkZGfVxcdXsxRTAwfS1cXHV7MUVGRn1dKyQvdTtcblxuICAgICAgLy8gSm9pbiBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcyBhbmQgbWVyZ2UgZW1wdHkgc3RyaW5ncyBzdXJyb3VuZGVkIGJ5IHdvcmQgY2hhcnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgY29uc3QgdG9rZW5QbHVzVHdvID0gdG9rZW5zW2kgKyAyXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF0b2tlbnNbaSArIDFdICYmXG4gICAgICAgICAgdG9rZW4gJiZcbiAgICAgICAgICB0b2tlblBsdXNUd28gJiZcbiAgICAgICAgICB3b3Jkcy50ZXN0KHRva2VuKSAmJlxuICAgICAgICAgIHdvcmRzLnRlc3QodG9rZW5QbHVzVHdvKVxuICAgICAgICApIHtcbiAgICAgICAgICB0b2tlbnNbaV0gKz0gdG9rZW5QbHVzVHdvO1xuICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDIpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2Vucy5maWx0ZXIoKHRva2VuKSA9PiB0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNwbGl0IHN0cmluZyBvbiBuZXcgbGluZXMgc3ltYm9sc1xuICAgICAgY29uc3QgdG9rZW5zOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgY29uc3QgbGluZXMgPSBzdHJpbmcuc3BsaXQoLyhcXG58XFxyXFxuKS8pO1xuXG4gICAgICAvLyBJZ25vcmUgZmluYWwgZW1wdHkgdG9rZW4gd2hlbiB0ZXh0IGVuZHMgd2l0aCBhIG5ld2xpbmVcbiAgICAgIGlmICghbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgbGluZXMucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXG4gICAgICBmb3IgKGNvbnN0IFtpLCBsaW5lXSBvZiBsaW5lcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBkZXRhaWxzIGJ5IGZpbHRlcmluZyByZWxldmFudCB3b3JkLWRpZmYgZm9yIGN1cnJlbnQgbGluZVxuICAvLyBhbmQgbWVyZ2UgXCJzcGFjZS1kaWZmXCIgaWYgc3Vycm91bmRlZCBieSB3b3JkLWRpZmYgZm9yIGNsZWFuZXIgZGlzcGxheXNcbiAgZnVuY3Rpb24gY3JlYXRlRGV0YWlscyhcbiAgICBsaW5lOiBEaWZmUmVzdWx0PHN0cmluZz4sXG4gICAgdG9rZW5zOiBBcnJheTxEaWZmUmVzdWx0PHN0cmluZz4+LFxuICApIHtcbiAgICByZXR1cm4gdG9rZW5zLmZpbHRlcigoeyB0eXBlIH0pID0+XG4gICAgICB0eXBlID09PSBsaW5lLnR5cGUgfHwgdHlwZSA9PT0gRGlmZlR5cGUuY29tbW9uXG4gICAgKS5tYXAoKHJlc3VsdCwgaSwgdCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW4gPSB0W2kgLSAxXTtcbiAgICAgIGlmIChcbiAgICAgICAgKHJlc3VsdC50eXBlID09PSBEaWZmVHlwZS5jb21tb24pICYmIHRva2VuICYmXG4gICAgICAgICh0b2tlbi50eXBlID09PSB0W2kgKyAxXT8udHlwZSkgJiYgL1xccysvLnRlc3QocmVzdWx0LnZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSBtdWx0aS1saW5lIGRpZmZcbiAgY29uc3QgZGlmZlJlc3VsdCA9IGRpZmYoXG4gICAgdG9rZW5pemUoYCR7dW5lc2NhcGUoQSl9XFxuYCksXG4gICAgdG9rZW5pemUoYCR7dW5lc2NhcGUoQil9XFxuYCksXG4gICk7XG5cbiAgY29uc3QgYWRkZWQgPSBbXSwgcmVtb3ZlZCA9IFtdO1xuICBmb3IgKGNvbnN0IHJlc3VsdCBvZiBkaWZmUmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC50eXBlID09PSBEaWZmVHlwZS5hZGRlZCkge1xuICAgICAgYWRkZWQucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnR5cGUgPT09IERpZmZUeXBlLnJlbW92ZWQpIHtcbiAgICAgIHJlbW92ZWQucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgd29yZC1kaWZmXG4gIGNvbnN0IGhhc01vcmVSZW1vdmVkTGluZXMgPSBhZGRlZC5sZW5ndGggPCByZW1vdmVkLmxlbmd0aDtcbiAgY29uc3QgYUxpbmVzID0gaGFzTW9yZVJlbW92ZWRMaW5lcyA/IGFkZGVkIDogcmVtb3ZlZDtcbiAgY29uc3QgYkxpbmVzID0gaGFzTW9yZVJlbW92ZWRMaW5lcyA/IHJlbW92ZWQgOiBhZGRlZDtcbiAgZm9yIChjb25zdCBhIG9mIGFMaW5lcykge1xuICAgIGxldCB0b2tlbnMgPSBbXSBhcyBBcnJheTxEaWZmUmVzdWx0PHN0cmluZz4+LFxuICAgICAgYjogdW5kZWZpbmVkIHwgRGlmZlJlc3VsdDxzdHJpbmc+O1xuICAgIC8vIFNlYXJjaCBhbm90aGVyIGRpZmYgbGluZSB3aXRoIGF0IGxlYXN0IG9uZSBjb21tb24gdG9rZW5cbiAgICB3aGlsZSAoYkxpbmVzLmxlbmd0aCkge1xuICAgICAgYiA9IGJMaW5lcy5zaGlmdCgpO1xuICAgICAgY29uc3QgdG9rZW5pemVkID0gW1xuICAgICAgICB0b2tlbml6ZShhLnZhbHVlLCB7IHdvcmREaWZmOiB0cnVlIH0pLFxuICAgICAgICB0b2tlbml6ZShiPy52YWx1ZSA/PyBcIlwiLCB7IHdvcmREaWZmOiB0cnVlIH0pLFxuICAgICAgXSBhcyBbc3RyaW5nW10sIHN0cmluZ1tdXTtcbiAgICAgIGlmIChoYXNNb3JlUmVtb3ZlZExpbmVzKSB0b2tlbml6ZWQucmV2ZXJzZSgpO1xuICAgICAgdG9rZW5zID0gZGlmZih0b2tlbml6ZWRbMF0sIHRva2VuaXplZFsxXSk7XG4gICAgICBpZiAoXG4gICAgICAgIHRva2Vucy5zb21lKCh7IHR5cGUsIHZhbHVlIH0pID0+XG4gICAgICAgICAgdHlwZSA9PT0gRGlmZlR5cGUuY29tbW9uICYmIHZhbHVlLnRyaW0oKS5sZW5ndGhcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZWdpc3RlciB3b3JkLWRpZmYgZGV0YWlsc1xuICAgIGEuZGV0YWlscyA9IGNyZWF0ZURldGFpbHMoYSwgdG9rZW5zKTtcbiAgICBpZiAoYikge1xuICAgICAgYi5kZXRhaWxzID0gY3JlYXRlRGV0YWlscyhiLCB0b2tlbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWZmUmVzdWx0O1xufVxuXG4vKipcbiAqIENvbG9ycyB0aGUgb3V0cHV0IG9mIGFzc2VydGlvbiBkaWZmc1xuICogQHBhcmFtIGRpZmZUeXBlIERpZmZlcmVuY2UgdHlwZSwgZWl0aGVyIGFkZGVkIG9yIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29sb3IoXG4gIGRpZmZUeXBlOiBEaWZmVHlwZSxcbiAgeyBiYWNrZ3JvdW5kID0gZmFsc2UgfSA9IHt9LFxuKTogKHM6IHN0cmluZykgPT4gc3RyaW5nIHtcbiAgLy8gVE9ETyhAbGl0dGxlZGl2eSk6IFJlbW92ZSB0aGlzIHdoZW4gd2UgY2FuIGRldGVjdFxuICAvLyB0cnVlIGNvbG9yIHRlcm1pbmFscy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL2Rlbm9fc3RkL2lzc3Vlcy8yNTc1XG4gIGJhY2tncm91bmQgPSBmYWxzZTtcbiAgc3dpdGNoIChkaWZmVHlwZSkge1xuICAgIGNhc2UgRGlmZlR5cGUuYWRkZWQ6XG4gICAgICByZXR1cm4gKHM6IHN0cmluZyk6IHN0cmluZyA9PlxuICAgICAgICBiYWNrZ3JvdW5kID8gYmdHcmVlbih3aGl0ZShzKSkgOiBncmVlbihib2xkKHMpKTtcbiAgICBjYXNlIERpZmZUeXBlLnJlbW92ZWQ6XG4gICAgICByZXR1cm4gKHM6IHN0cmluZyk6IHN0cmluZyA9PiBiYWNrZ3JvdW5kID8gYmdSZWQod2hpdGUocykpIDogcmVkKGJvbGQocykpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gd2hpdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBQcmVmaXhlcyBgK2Agb3IgYC1gIGluIGRpZmYgb3V0cHV0XG4gKiBAcGFyYW0gZGlmZlR5cGUgRGlmZmVyZW5jZSB0eXBlLCBlaXRoZXIgYWRkZWQgb3IgcmVtb3ZlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVTaWduKGRpZmZUeXBlOiBEaWZmVHlwZSk6IHN0cmluZyB7XG4gIHN3aXRjaCAoZGlmZlR5cGUpIHtcbiAgICBjYXNlIERpZmZUeXBlLmFkZGVkOlxuICAgICAgcmV0dXJuIFwiKyAgIFwiO1xuICAgIGNhc2UgRGlmZlR5cGUucmVtb3ZlZDpcbiAgICAgIHJldHVybiBcIi0gICBcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiICAgIFwiO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoXG4gIGRpZmZSZXN1bHQ6IFJlYWRvbmx5QXJyYXk8RGlmZlJlc3VsdDxzdHJpbmc+PixcbiAgeyBzdHJpbmdEaWZmID0gZmFsc2UgfSA9IHt9LFxuKTogc3RyaW5nW10ge1xuICBjb25zdCBtZXNzYWdlczogc3RyaW5nW10gPSBbXSwgZGlmZk1lc3NhZ2VzOiBzdHJpbmdbXSA9IFtdO1xuICBtZXNzYWdlcy5wdXNoKFwiXCIpO1xuICBtZXNzYWdlcy5wdXNoKFwiXCIpO1xuICBtZXNzYWdlcy5wdXNoKFxuICAgIGAgICAgJHtncmF5KGJvbGQoXCJbRGlmZl1cIikpfSAke3JlZChib2xkKFwiQWN0dWFsXCIpKX0gLyAke1xuICAgICAgZ3JlZW4oYm9sZChcIkV4cGVjdGVkXCIpKVxuICAgIH1gLFxuICApO1xuICBtZXNzYWdlcy5wdXNoKFwiXCIpO1xuICBtZXNzYWdlcy5wdXNoKFwiXCIpO1xuICBkaWZmUmVzdWx0LmZvckVhY2goKHJlc3VsdDogRGlmZlJlc3VsdDxzdHJpbmc+KSA9PiB7XG4gICAgY29uc3QgYyA9IGNyZWF0ZUNvbG9yKHJlc3VsdC50eXBlKTtcbiAgICBjb25zdCBsaW5lID0gcmVzdWx0LmRldGFpbHM/Lm1hcCgoZGV0YWlsKSA9PlxuICAgICAgZGV0YWlsLnR5cGUgIT09IERpZmZUeXBlLmNvbW1vblxuICAgICAgICA/IGNyZWF0ZUNvbG9yKGRldGFpbC50eXBlLCB7IGJhY2tncm91bmQ6IHRydWUgfSkoZGV0YWlsLnZhbHVlKVxuICAgICAgICA6IGRldGFpbC52YWx1ZVxuICAgICkuam9pbihcIlwiKSA/PyByZXN1bHQudmFsdWU7XG4gICAgZGlmZk1lc3NhZ2VzLnB1c2goYyhgJHtjcmVhdGVTaWduKHJlc3VsdC50eXBlKX0ke2xpbmV9YCkpO1xuICB9KTtcbiAgbWVzc2FnZXMucHVzaCguLi4oc3RyaW5nRGlmZiA/IFtkaWZmTWVzc2FnZXMuam9pbihcIlwiKV0gOiBkaWZmTWVzc2FnZXMpKTtcbiAgbWVzc2FnZXMucHVzaChcIlwiKTtcblxuICByZXR1cm4gbWVzc2FnZXM7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUVyQyxTQUNFLE9BQU8sRUFDUCxLQUFLLEVBQ0wsSUFBSSxFQUNKLElBQUksRUFDSixLQUFLLEVBQ0wsR0FBRyxFQUNILEtBQUssUUFDQSxtQkFBbUI7QUFPMUIsT0FBTyxNQUFNLFdBQVc7RUFDdEIsU0FBUztFQUNULFFBQVE7RUFDUixPQUFPO0FBQ1QsRUFBVztBQVVYLE1BQU0sVUFBVTtBQUNoQixNQUFNLFNBQVM7QUFDZixNQUFNLFFBQVE7QUFFZCxTQUFTLGFBQWdCLENBQU0sRUFBRSxDQUFNLEVBQUUsT0FBaUI7RUFDeEQsTUFBTSxTQUFjLEVBQUU7RUFDdEIsSUFBSSxFQUFFLE1BQU0sS0FBSyxLQUFLLEVBQUUsTUFBTSxLQUFLLEdBQUcsT0FBTyxFQUFFO0VBQy9DLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLE1BQU0sR0FBRyxLQUFLLEVBQUc7SUFDeEQsTUFBTSxJQUFJLFVBQVUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxHQUFHLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFO0lBQzlDLE1BQU0sSUFBSSxVQUFVLENBQUMsQ0FBQyxFQUFFLE1BQU0sR0FBRyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtJQUM5QyxJQUFJLE1BQU0sYUFBYSxNQUFNLEdBQUc7TUFDOUIsT0FBTyxJQUFJLENBQUM7SUFDZCxPQUFPO01BQ0wsT0FBTztJQUNUO0VBQ0Y7RUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTLGNBQWlCLElBQVE7RUFDaEMsSUFBSSxTQUFTLFdBQVc7SUFDdEIsTUFBTSxNQUFNO0VBQ2Q7RUFDQSxPQUFPO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ0QsT0FBTyxTQUFTLEtBQVEsQ0FBTSxFQUFFLENBQU07RUFDcEMsTUFBTSxlQUFlLGFBQWEsR0FBRztFQUNyQyxNQUFNLGVBQWUsYUFDbkIsRUFBRSxLQUFLLENBQUMsYUFBYSxNQUFNLEdBQzNCLEVBQUUsS0FBSyxDQUFDLGFBQWEsTUFBTSxHQUMzQixNQUNBLE9BQU87RUFDVCxJQUFJLGFBQWEsTUFBTSxHQUNuQixFQUFFLEtBQUssQ0FBQyxhQUFhLE1BQU0sRUFBRSxDQUFDLGFBQWEsTUFBTSxJQUNqRCxFQUFFLEtBQUssQ0FBQyxhQUFhLE1BQU07RUFDL0IsSUFBSSxhQUFhLE1BQU0sR0FDbkIsRUFBRSxLQUFLLENBQUMsYUFBYSxNQUFNLEVBQUUsQ0FBQyxhQUFhLE1BQU0sSUFDakQsRUFBRSxLQUFLLENBQUMsYUFBYSxNQUFNO0VBQy9CLE1BQU0sVUFBVSxFQUFFLE1BQU0sR0FBRyxFQUFFLE1BQU07RUFDbkMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxVQUFVO0lBQUM7SUFBRztHQUFFLEdBQUc7SUFBQztJQUFHO0dBQUU7RUFDbEMsTUFBTSxJQUFJLEVBQUUsTUFBTTtFQUNsQixNQUFNLElBQUksRUFBRSxNQUFNO0VBQ2xCLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLGFBQWEsTUFBTSxJQUFJLENBQUMsYUFBYSxNQUFNLEVBQUUsT0FBTyxFQUFFO0VBQ3ZFLElBQUksQ0FBQyxHQUFHO0lBQ04sT0FBTztTQUNGLGFBQWEsR0FBRyxDQUNqQixDQUFDLElBQTRCLENBQUM7VUFBRSxNQUFNLFNBQVMsTUFBTTtVQUFFLE9BQU87UUFBRSxDQUFDO1NBRWhFLEVBQUUsR0FBRyxDQUNOLENBQUMsSUFBNEIsQ0FBQztVQUM1QixNQUFNLFVBQVUsU0FBUyxLQUFLLEdBQUcsU0FBUyxPQUFPO1VBQ2pELE9BQU87UUFDVCxDQUFDO1NBRUEsYUFBYSxHQUFHLENBQ2pCLENBQUMsSUFBNEIsQ0FBQztVQUFFLE1BQU0sU0FBUyxNQUFNO1VBQUUsT0FBTztRQUFFLENBQUM7S0FFcEU7RUFDSDtFQUNBLE1BQU0sU0FBUztFQUNmLE1BQU0sUUFBUSxJQUFJO0VBQ2xCLE1BQU0sT0FBTyxJQUFJLElBQUk7RUFDckIsTUFBTSxLQUFzQixNQUFNLElBQUksQ0FDcEM7SUFBRSxRQUFRO0VBQUssR0FDZixJQUFNLENBQUM7TUFBRSxHQUFHLENBQUM7TUFBRyxJQUFJLENBQUM7SUFBRSxDQUFDO0VBRzFCOzs7Ozs7O0dBT0MsR0FDRCxNQUFNLFNBQVMsSUFBSSxZQUFZLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxJQUFJO0VBQ3BELE1BQU0scUJBQXFCLE9BQU8sTUFBTSxHQUFHO0VBQzNDLElBQUksTUFBTTtFQUNWLElBQUksSUFBSSxDQUFDO0VBRVQsU0FBUyxVQUNQLENBQU0sRUFDTixDQUFNLEVBQ04sT0FBc0IsRUFDdEIsT0FBZ0I7SUFLaEIsTUFBTSxJQUFJLEVBQUUsTUFBTTtJQUNsQixNQUFNLElBQUksRUFBRSxNQUFNO0lBQ2xCLE1BQU0sU0FBeUMsRUFBRTtJQUNqRCxJQUFJLElBQUksSUFBSTtJQUNaLElBQUksSUFBSSxJQUFJO0lBQ1osSUFBSSxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMxQixJQUFJLE9BQU8sTUFBTSxDQUFDLFFBQVEsRUFBRSxHQUFHLG1CQUFtQjtJQUNsRCxNQUFPLEtBQU07TUFDWCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU07TUFDakIsTUFBTSxPQUFPO01BQ2IsSUFBSSxTQUFTLFNBQVM7UUFDcEIsT0FBTyxPQUFPLENBQUM7VUFDYixNQUFNLFVBQVUsU0FBUyxPQUFPLEdBQUcsU0FBUyxLQUFLO1VBQ2pELE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDYjtRQUNBLEtBQUs7TUFDUCxPQUFPLElBQUksU0FBUyxPQUFPO1FBQ3pCLE9BQU8sT0FBTyxDQUFDO1VBQ2IsTUFBTSxVQUFVLFNBQVMsS0FBSyxHQUFHLFNBQVMsT0FBTztVQUNqRCxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQ2I7UUFDQSxLQUFLO01BQ1AsT0FBTztRQUNMLE9BQU8sT0FBTyxDQUFDO1VBQUUsTUFBTSxTQUFTLE1BQU07VUFBRSxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQUU7UUFDckQsS0FBSztRQUNMLEtBQUs7TUFDUDtNQUNBLElBQUksTUFBTSxDQUFDLEtBQUs7TUFDaEIsT0FBTyxNQUFNLENBQUMsT0FBTyxtQkFBbUI7SUFDMUM7SUFDQSxPQUFPO0VBQ1Q7RUFFQSxTQUFTLFNBQ1AsS0FBZ0MsRUFDaEMsSUFBK0IsRUFDL0IsQ0FBUyxFQUNULENBQVM7SUFFVCxJQUFJLFNBQVMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLFFBQVEsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHO01BQ3BELE9BQU87UUFBRSxHQUFHO1FBQUcsSUFBSTtNQUFFO0lBQ3ZCO0lBQ0EsTUFBTSxXQUFXLEFBQUMsTUFBTSxNQUFNLENBQUMsS0FDN0IsTUFBTSxLQUNOLENBQUMsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUk7SUFDckMsSUFBSSxTQUFTLFVBQVU7TUFDckIsTUFBTSxPQUFPLE1BQU0sRUFBRTtNQUNyQjtNQUNBLE1BQU0sQ0FBQyxJQUFJLEdBQUc7TUFDZCxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRztNQUNuQyxPQUFPO1FBQUUsR0FBRyxNQUFNLENBQUM7UUFBRSxJQUFJO01BQUk7SUFDL0IsT0FBTyxJQUFJLFFBQVEsQ0FBQyxVQUFVO01BQzVCLE1BQU0sT0FBTyxLQUFLLEVBQUU7TUFDcEI7TUFDQSxNQUFNLENBQUMsSUFBSSxHQUFHO01BQ2QsTUFBTSxDQUFDLE1BQU0sbUJBQW1CLEdBQUc7TUFDbkMsT0FBTztRQUFFLEdBQUcsS0FBSyxDQUFDLEdBQUc7UUFBRyxJQUFJO01BQUk7SUFDbEMsT0FBTztNQUNMLE1BQU0sSUFBSSxNQUFNO0lBQ2xCO0VBQ0Y7RUFFQSxTQUFTLE1BQ1AsQ0FBUyxFQUNULEtBQWdDLEVBQ2hDLElBQStCLEVBQy9CLE9BQWUsRUFDZixDQUFNLEVBQ04sQ0FBTTtJQUVOLE1BQU0sSUFBSSxFQUFFLE1BQU07SUFDbEIsTUFBTSxJQUFJLEVBQUUsTUFBTTtJQUNsQixJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksR0FBRyxPQUFPO01BQUUsR0FBRyxDQUFDO01BQUcsSUFBSSxDQUFDO0lBQUU7SUFDNUMsTUFBTSxLQUFLLFNBQVMsT0FBTyxNQUFNLEdBQUc7SUFDcEMsTUFBTyxHQUFHLENBQUMsR0FBRyxJQUFJLEtBQUssR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFFO01BQzFELE1BQU0sT0FBTyxHQUFHLEVBQUU7TUFDbEI7TUFDQSxHQUFHLEVBQUUsR0FBRztNQUNSLEdBQUcsQ0FBQyxJQUFJO01BQ1IsTUFBTSxDQUFDLElBQUksR0FBRztNQUNkLE1BQU0sQ0FBQyxNQUFNLG1CQUFtQixHQUFHO0lBQ3JDO0lBQ0EsT0FBTztFQUNUO0VBRUEsSUFBSSxZQUFZLGNBQTZCLEVBQUUsQ0FBQyxRQUFRLE9BQU87RUFDL0QsTUFBTyxhQUFhLFVBQVUsQ0FBQyxHQUFHLEVBQUc7SUFDbkMsSUFBSSxJQUFJO0lBQ1IsSUFBSyxJQUFJLElBQUksQ0FBQyxHQUFHLElBQUksT0FBTyxFQUFFLEVBQUc7TUFDL0IsRUFBRSxDQUFDLElBQUksT0FBTyxHQUFHLE1BQ2YsR0FDQSxFQUFFLENBQUMsSUFBSSxJQUFJLE9BQU8sRUFDbEIsRUFBRSxDQUFDLElBQUksSUFBSSxPQUFPLEVBQ2xCLFFBQ0EsR0FDQTtJQUVKO0lBQ0EsSUFBSyxJQUFJLElBQUksUUFBUSxHQUFHLElBQUksT0FBTyxFQUFFLEVBQUc7TUFDdEMsRUFBRSxDQUFDLElBQUksT0FBTyxHQUFHLE1BQ2YsR0FDQSxFQUFFLENBQUMsSUFBSSxJQUFJLE9BQU8sRUFDbEIsRUFBRSxDQUFDLElBQUksSUFBSSxPQUFPLEVBQ2xCLFFBQ0EsR0FDQTtJQUVKO0lBQ0EsRUFBRSxDQUFDLFFBQVEsT0FBTyxHQUFHLE1BQ25CLE9BQ0EsRUFBRSxDQUFDLFFBQVEsSUFBSSxPQUFPLEVBQ3RCLEVBQUUsQ0FBQyxRQUFRLElBQUksT0FBTyxFQUN0QixRQUNBLEdBQ0E7SUFFRixZQUFZLGNBQWMsRUFBRSxDQUFDLFFBQVEsT0FBTztFQUM5QztFQUNBLE9BQU87T0FDRixhQUFhLEdBQUcsQ0FDakIsQ0FBQyxJQUE0QixDQUFDO1FBQUUsTUFBTSxTQUFTLE1BQU07UUFBRSxPQUFPO01BQUUsQ0FBQztPQUVoRSxVQUFVLEdBQUcsR0FBRyxXQUFXO09BQzNCLGFBQWEsR0FBRyxDQUNqQixDQUFDLElBQTRCLENBQUM7UUFBRSxNQUFNLFNBQVMsTUFBTTtRQUFFLE9BQU87TUFBRSxDQUFDO0dBRXBFO0FBQ0g7QUFFQTs7Ozs7Q0FLQyxHQUNELE9BQU8sU0FBUyxRQUFRLENBQVMsRUFBRSxDQUFTO0VBQzFDLFNBQVMsU0FBUyxNQUFjO0lBQzlCLGlDQUFpQztJQUNqQyxnSEFBZ0g7SUFDaEgsT0FBTyxPQUNKLFVBQVUsQ0FBQyxNQUFNLE9BQ2pCLFVBQVUsQ0FBQyxNQUFNLE9BQ2pCLFVBQVUsQ0FBQyxNQUFNLE9BQ2pCLFVBQVUsQ0FBQyxNQUFNLE9BQ2pCLFVBQVUsQ0FDVCxlQUNBLENBQUMsTUFBUSxRQUFRLE9BQU8sUUFBUSxRQUFRLE9BQU8sVUFBVTtFQUUvRDtFQUVBLFNBQVMsU0FBUyxNQUFjLEVBQUUsRUFBRSxXQUFXLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN6RCxJQUFJLFVBQVU7TUFDWixxQ0FBcUM7TUFDckMsTUFBTSxTQUFTLE9BQU8sS0FBSyxDQUFDO01BQzVCLCtCQUErQjtNQUMvQixNQUFNLFFBQ0o7TUFFRixpSEFBaUg7TUFDakgsSUFBSyxJQUFJLElBQUksR0FBRyxJQUFJLE9BQU8sTUFBTSxHQUFHLEdBQUcsSUFBSztRQUMxQyxNQUFNLFFBQVEsTUFBTSxDQUFDLEVBQUU7UUFDdkIsTUFBTSxlQUFlLE1BQU0sQ0FBQyxJQUFJLEVBQUU7UUFDbEMsSUFDRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFDZCxTQUNBLGdCQUNBLE1BQU0sSUFBSSxDQUFDLFVBQ1gsTUFBTSxJQUFJLENBQUMsZUFDWDtVQUNBLE1BQU0sQ0FBQyxFQUFFLElBQUk7VUFDYixPQUFPLE1BQU0sQ0FBQyxJQUFJLEdBQUc7VUFDckI7UUFDRjtNQUNGO01BQ0EsT0FBTyxPQUFPLE1BQU0sQ0FBQyxDQUFDLFFBQVU7SUFDbEMsT0FBTztNQUNMLG9DQUFvQztNQUNwQyxNQUFNLFNBQW1CLEVBQUU7TUFDM0IsTUFBTSxRQUFRLE9BQU8sS0FBSyxDQUFDO01BRTNCLHlEQUF5RDtNQUN6RCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sTUFBTSxHQUFHLEVBQUUsRUFBRTtRQUM1QixNQUFNLEdBQUc7TUFDWDtNQUVBLDJEQUEyRDtNQUMzRCxLQUFLLE1BQU0sQ0FBQyxHQUFHLEtBQUssSUFBSSxNQUFNLE9BQU8sR0FBSTtRQUN2QyxJQUFJLElBQUksR0FBRztVQUNULE1BQU0sQ0FBQyxPQUFPLE1BQU0sR0FBRyxFQUFFLElBQUk7UUFDL0IsT0FBTztVQUNMLE9BQU8sSUFBSSxDQUFDO1FBQ2Q7TUFDRjtNQUNBLE9BQU87SUFDVDtFQUNGO0VBRUEsa0VBQWtFO0VBQ2xFLHlFQUF5RTtFQUN6RSxTQUFTLGNBQ1AsSUFBd0IsRUFDeEIsTUFBaUM7SUFFakMsT0FBTyxPQUFPLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQzVCLFNBQVMsS0FBSyxJQUFJLElBQUksU0FBUyxTQUFTLE1BQU0sRUFDOUMsR0FBRyxDQUFDLENBQUMsUUFBUSxHQUFHO01BQ2hCLE1BQU0sUUFBUSxDQUFDLENBQUMsSUFBSSxFQUFFO01BQ3RCLElBQ0UsQUFBQyxPQUFPLElBQUksS0FBSyxTQUFTLE1BQU0sSUFBSyxTQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsUUFBUyxNQUFNLElBQUksQ0FBQyxPQUFPLEtBQUssR0FDMUQ7UUFDQSxPQUFPO1VBQ0wsR0FBRyxNQUFNO1VBQ1QsTUFBTSxNQUFNLElBQUk7UUFDbEI7TUFDRjtNQUNBLE9BQU87SUFDVDtFQUNGO0VBRUEsMEJBQTBCO0VBQzFCLE1BQU0sYUFBYSxLQUNqQixTQUFTLENBQUMsRUFBRSxTQUFTLEdBQUcsRUFBRSxDQUFDLEdBQzNCLFNBQVMsQ0FBQyxFQUFFLFNBQVMsR0FBRyxFQUFFLENBQUM7RUFHN0IsTUFBTSxRQUFRLEVBQUUsRUFBRSxVQUFVLEVBQUU7RUFDOUIsS0FBSyxNQUFNLFVBQVUsV0FBWTtJQUMvQixJQUFJLE9BQU8sSUFBSSxLQUFLLFNBQVMsS0FBSyxFQUFFO01BQ2xDLE1BQU0sSUFBSSxDQUFDO0lBQ2I7SUFDQSxJQUFJLE9BQU8sSUFBSSxLQUFLLFNBQVMsT0FBTyxFQUFFO01BQ3BDLFFBQVEsSUFBSSxDQUFDO0lBQ2Y7RUFDRjtFQUVBLG9CQUFvQjtFQUNwQixNQUFNLHNCQUFzQixNQUFNLE1BQU0sR0FBRyxRQUFRLE1BQU07RUFDekQsTUFBTSxTQUFTLHNCQUFzQixRQUFRO0VBQzdDLE1BQU0sU0FBUyxzQkFBc0IsVUFBVTtFQUMvQyxLQUFLLE1BQU0sS0FBSyxPQUFRO0lBQ3RCLElBQUksU0FBUyxFQUFFLEVBQ2I7SUFDRiwwREFBMEQ7SUFDMUQsTUFBTyxPQUFPLE1BQU0sQ0FBRTtNQUNwQixJQUFJLE9BQU8sS0FBSztNQUNoQixNQUFNLFlBQVk7UUFDaEIsU0FBUyxFQUFFLEtBQUssRUFBRTtVQUFFLFVBQVU7UUFBSztRQUNuQyxTQUFTLEdBQUcsU0FBUyxJQUFJO1VBQUUsVUFBVTtRQUFLO09BQzNDO01BQ0QsSUFBSSxxQkFBcUIsVUFBVSxPQUFPO01BQzFDLFNBQVMsS0FBSyxTQUFTLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxFQUFFO01BQ3hDLElBQ0UsT0FBTyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FDMUIsU0FBUyxTQUFTLE1BQU0sSUFBSSxNQUFNLElBQUksR0FBRyxNQUFNLEdBRWpEO1FBQ0E7TUFDRjtJQUNGO0lBQ0EsNkJBQTZCO0lBQzdCLEVBQUUsT0FBTyxHQUFHLGNBQWMsR0FBRztJQUM3QixJQUFJLEdBQUc7TUFDTCxFQUFFLE9BQU8sR0FBRyxjQUFjLEdBQUc7SUFDL0I7RUFDRjtFQUVBLE9BQU87QUFDVDtBQUVBOzs7Q0FHQyxHQUNELFNBQVMsWUFDUCxRQUFrQixFQUNsQixFQUFFLGFBQWEsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0VBRTNCLG9EQUFvRDtFQUNwRCx3QkFBd0I7RUFDeEIsbURBQW1EO0VBQ25ELGFBQWE7RUFDYixPQUFRO0lBQ04sS0FBSyxTQUFTLEtBQUs7TUFDakIsT0FBTyxDQUFDLElBQ04sYUFBYSxRQUFRLE1BQU0sTUFBTSxNQUFNLEtBQUs7SUFDaEQsS0FBSyxTQUFTLE9BQU87TUFDbkIsT0FBTyxDQUFDLElBQXNCLGFBQWEsTUFBTSxNQUFNLE1BQU0sSUFBSSxLQUFLO0lBQ3hFO01BQ0UsT0FBTztFQUNYO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTLFdBQVcsUUFBa0I7RUFDcEMsT0FBUTtJQUNOLEtBQUssU0FBUyxLQUFLO01BQ2pCLE9BQU87SUFDVCxLQUFLLFNBQVMsT0FBTztNQUNuQixPQUFPO0lBQ1Q7TUFDRSxPQUFPO0VBQ1g7QUFDRjtBQUVBLE9BQU8sU0FBUyxhQUNkLFVBQTZDLEVBQzdDLEVBQUUsYUFBYSxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7RUFFM0IsTUFBTSxXQUFxQixFQUFFLEVBQUUsZUFBeUIsRUFBRTtFQUMxRCxTQUFTLElBQUksQ0FBQztFQUNkLFNBQVMsSUFBSSxDQUFDO0VBQ2QsU0FBUyxJQUFJLENBQ1gsQ0FBQyxJQUFJLEVBQUUsS0FBSyxLQUFLLFdBQVcsQ0FBQyxFQUFFLElBQUksS0FBSyxXQUFXLEdBQUcsRUFDcEQsTUFBTSxLQUFLLGFBQ1osQ0FBQztFQUVKLFNBQVMsSUFBSSxDQUFDO0VBQ2QsU0FBUyxJQUFJLENBQUM7RUFDZCxXQUFXLE9BQU8sQ0FBQyxDQUFDO0lBQ2xCLE1BQU0sSUFBSSxZQUFZLE9BQU8sSUFBSTtJQUNqQyxNQUFNLE9BQU8sT0FBTyxPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQ2hDLE9BQU8sSUFBSSxLQUFLLFNBQVMsTUFBTSxHQUMzQixZQUFZLE9BQU8sSUFBSSxFQUFFO1FBQUUsWUFBWTtNQUFLLEdBQUcsT0FBTyxLQUFLLElBQzNELE9BQU8sS0FBSyxFQUNoQixLQUFLLE9BQU8sT0FBTyxLQUFLO0lBQzFCLGFBQWEsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsT0FBTyxJQUFJLEVBQUUsRUFBRSxLQUFLLENBQUM7RUFDekQ7RUFDQSxTQUFTLElBQUksSUFBSyxhQUFhO0lBQUMsYUFBYSxJQUFJLENBQUM7R0FBSSxHQUFHO0VBQ3pELFNBQVMsSUFBSSxDQUFDO0VBRWQsT0FBTztBQUNUIn0=
// denoCacheMetadata=1103129713682199687,15270072289195077536