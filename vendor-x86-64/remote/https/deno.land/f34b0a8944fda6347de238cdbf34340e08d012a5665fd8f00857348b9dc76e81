export const KEY = "_f";

interface Signal<T> {
  peek(): T;
  value: T;
}

function b64decode(b64: string): Uint8Array {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

const INVALID_REFERENCE_ERROR = "Invalid reference";

function getPropertyFromPath(o: object, path: string[]): object {
  for (const key of path) {
    if (key === null) continue;
    if (key !== "value" && !Object.hasOwn(o, key)) {
      throw new Error(INVALID_REFERENCE_ERROR);
    }
    // deno-lint-ignore no-explicit-any
    o = (o as any)[key];
  }
  return o;
}

export function deserialize(
  str: string,
  signal?: <T>(a: T) => Signal<T>,
): unknown {
  function reviver(this: unknown, _key: string, value: unknown): unknown {
    if (typeof value === "object" && value && KEY in value) {
      // deno-lint-ignore no-explicit-any
      const v: any = value;
      if (v[KEY] === "s") {
        return signal!(v.v);
      }
      if (v[KEY] === "b") {
        return BigInt(v.d);
      }
      if (v[KEY] === "u8a") {
        return b64decode(v.d);
      }
      if (v[KEY] === "l") {
        const val = v.v;
        val[KEY] = v.k;
        return val;
      }
      throw new Error(`Unknown key: ${v[KEY]}`);
    }
    return value;
  }
  const { v, r } = JSON.parse(str, reviver);
  const references = (r ?? []) as [string[], ...string[][]][];
  for (const [targetPath, ...refPaths] of references) {
    const target = getPropertyFromPath(v, targetPath);
    for (const refPath of refPaths) {
      if (refPath.length === 0) throw new Error(INVALID_REFERENCE_ERROR);
      // set the reference to the target object
      const parent = getPropertyFromPath(v, refPath.slice(0, -1));
      const key = refPath[refPath.length - 1]!;
      if (key !== "value" && !Object.hasOwn(parent, key)) {
        throw new Error(INVALID_REFERENCE_ERROR);
      }
      // deno-lint-ignore no-explicit-any
      (parent as any)[key] = target;
    }
  }
  return v;
}

// denoCacheMetadata={"headers":{"x-amz-cf-pop":"AMS58-P5","x-amz-version-id":"Q.F2mXKNXeQxuffJn_6uemItFcj2O4k5","cache-status":"deno; hit","date":"Mon, 24 Nov 2025 22:18:17 GMT","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","vary":"Accept-Encoding, Origin","x-frame-options":"DENY","content-length":"2087","age":"167768","cache-control":"public, max-age=31536000, immutable","referrer-policy":"strict-origin-when-cross-origin","via":"1.1 a44309111e5e1050ff485adaa4681ad0.cloudfront.net (CloudFront),HTTP/2 ams.vultr.prod.deno-cluster.net","cross-origin-opener-policy":"same-origin","access-control-allow-origin":"*","accept-ranges":"bytes","alt-svc":"h3=\":443\"; ma=86400","x-amz-cf-id":"23ZGEQXuMSeNVvX3v_lMMzLjHW8vSQgPZfM6oxdO7Zz3dTbde1K-IA==","last-modified":"Fri, 22 Mar 2024 21:26:14 GMT","content-type":"application/typescript; charset=utf-8","strict-transport-security":"max-age=63072000; includeSubDomains; preload","x-amz-server-side-encryption":"AES256","etag":"\"c484f9bd3e84ecdfd0151e9defad5d5b\"","server-timing":"fetchSource;dur=356","x-content-type-options":"nosniff","cross-origin-embedder-policy":"same-origin","server":"AmazonS3,deployd","x-cache":"Hit from cloudfront","x-deno-trace-id":"f32243c8ab6f234bea9b4ac296f5c5dd","x-amz-replication-status":"COMPLETED","cross-origin-resource-policy":"same-origin"},"url":"https://deno.land/x/fresh@1.6.8/src/runtime/deserializer.ts","time":1764190464}